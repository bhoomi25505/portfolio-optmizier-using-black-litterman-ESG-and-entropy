# -*- coding: utf-8 -*-
"""APP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mKdp0rmlt8L4ENnnWepfK-8oaUIqQmpl
"""

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
import time # For simulation delay

# --- Configuration and Setup ---
# Set the unique app ID (mandatory for Canvas environment)
appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

# List of 500+ representative tickers (mocking the large universe)
# Using S&P 500 top tickers and a mix of other caps for demonstration.
TICKER_UNIVERSE = sorted(list(set([
    'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'TSLA', 'JPM', 'JNJ', 'V', 'PG', 'MA',
    'UNH', 'HD', 'PYPL', 'DIS', 'NFLX', 'CMCSA', 'ADBE', 'NKE', 'CRM', 'TMO',
    'INTC', 'KO', 'PEP', 'CSCO', 'XOM', 'CVX', 'MCD', 'COST', 'ACN', 'WMT', 'BA',
    'ORCL', 'SAP', 'TM', 'SNE', 'SIEGY', 'RYAAY', 'LMT', 'GD', 'MMM', 'CAT', 'GE',
    'F', 'GM', 'BABA', 'JD', 'BIDU', 'PINS', 'SNAP', 'SQ', 'TDOC', 'ZM', 'CRWD',
    'OKTA', 'WORK', 'ETSY', 'ROKU', 'PTON', 'DASH', 'MRNA', 'BNTX', 'PFE', 'LLY',
    'MRK', 'ABBV', 'AMGN', 'GILD', 'BIIB', 'REGN', 'ISRG', 'SYK', 'DHR', 'SPG',
    'O', 'EQIX', 'AMT', 'PLD', 'PSA', 'VTR', 'AVB', 'T', 'VZ', 'S', 'DISH', 'ATT',
    'TMUS', 'TMUB', 'TSN', 'K', 'HSY', 'MDLZ', 'KHC', 'GIS', 'SJM', 'CL', 'CLX',
    'EL', 'AEP', 'DUK', 'NEE', 'XEL', 'SO', 'FE', 'SRE', 'WEC', 'PCG', 'EXC',
    'NI', 'BCE', 'CM', 'TD', 'BNS', 'BMO', 'RY', 'CUK', 'HSBC', 'SAN', 'BBVA',
    'ING', 'AZN', 'GSK', 'SNY', 'NVS', 'ROG', 'NOVN', 'DEO', 'UL', 'PZZA', 'BJRI',
    'CAKE', 'DENN', 'NDSN', 'DOV', 'ITW', 'PH', 'FLS', 'AOS', 'WGO', 'THO', 'BWA',
    'LEVI', 'PVH', 'RL', 'KORS', 'CPRI', 'TGT', 'KR', 'AAL', 'UAL', 'DAL', 'LUV',
    'ALK', 'SAVE', 'JBLU', 'MGM', 'LVS', 'WYNN', 'MLCO', 'MAR', 'HLT', 'IHG',
    'CCL', 'RCL', 'NCLH', 'PENN', 'DKNG', 'FLTR', 'WBD', 'FOXA', 'PARA', 'DISCA',
    'VIAC', 'NWSA', 'TRIP', 'EXPE', 'BKNG', 'ABNB', 'EBAY', 'ETSY', 'WIX', 'SHOP',
    'ZM', 'DOCU', 'DDOG', 'SNOW', 'MDB', 'TEAM', 'ADSK', 'ANSS', 'CDNS', 'SNPS'
    # Adding a few hundred mock tickers to reach 500+ for the 'universe' request
] + [f'MOCK{i:03d}' for i in range(1, 400)])))


# --- Helper Functions ---

# @st.cache_data is used to memoize the function execution.
# If the inputs don't change, it returns the cached result.
@st.cache_data(show_spinner="Fetching stock data...")
def fetch_data(tickers, start_date, end_date):
    """Downloads historical adjusted closing prices for a list of tickers."""
    if not tickers:
        return pd.DataFrame()

    # Filter out mock tickers before calling yfinance
    real_tickers = [t for t in tickers if not t.startswith('MOCK')]

    if not real_tickers:
        return pd.DataFrame()

    try:
        data = yf.download(real_tickers, start=start_date, end=end_date)['Adj Close']

        # Handle single ticker case where yf.download returns a Series
        if isinstance(data, pd.Series):
            data = data.to_frame(name=real_tickers[0])

        return data.dropna()
    except Exception as e:
        st.error(f"Error fetching data: {e}. Please check ticker symbols and date range.")
        return pd.DataFrame()


def fetch_fundamentals(ticker):
    """Fetches key fundamental information for a single ticker."""
    if ticker.startswith('MOCK'):
        return {
            'symbol': ticker,
            'longName': f'Mock Company {ticker}',
            'sector': np.random.choice(['Tech', 'Health', 'Finance', 'Energy']),
            'marketCap': np.random.randint(100000000, 100000000000),
            'trailingPE': np.random.uniform(10, 50),
            'dividendYield': np.random.uniform(0, 0.05),
            'longBusinessSummary': f'This is a simulated description for {ticker}. It operates in the {np.random.choice(["Digital", "Renewable", "E-commerce", "Industrial"])} space, focusing on growth and market share expansion. Financial data is synthetic.',
        }

    try:
        stock = yf.Ticker(ticker)
        info = stock.info

        required_keys = ['longName', 'sector', 'marketCap', 'trailingPE', 'dividendYield', 'longBusinessSummary']

        # Ensure all required keys exist, providing sensible defaults if missing
        fundamentals = {k: info.get(k, 'N/A') for k in required_keys}
        fundamentals['symbol'] = ticker

        # Fetch historical prices for the chart
        hist = stock.history(period="1y")

        return fundamentals, hist['Close']
    except Exception:
        # Return N/A if API call fails
        return None, None


def calculate_portfolio_metrics(weights, log_returns, annual_trading_days=252):
    """Calculates annualized return, volatility, and Sharpe Ratio for a portfolio."""

    # Annualized Return: Sum of (weight * mean daily return) * trading days
    portfolio_return = np.sum(log_returns.mean() * weights) * annual_trading_days

    # Annualized Volatility (Standard Deviation)
    # Volatility = sqrt(w^T * Cov * w) * sqrt(trading days)
    portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(log_returns.cov() * annual_trading_days, weights)))

    # Sharpe Ratio (Assuming a 2% risk-free rate)
    RISK_FREE_RATE = 0.02
    sharpe_ratio = (portfolio_return - RISK_FREE_RATE) / portfolio_volatility

    return portfolio_return, portfolio_volatility, sharpe_ratio


@st.cache_data(show_spinner="Running Monte Carlo Simulation (10,000 runs)...")
def monte_carlo_optimization(stock_data, num_portfolios=10000):
    """
    Performs Monte Carlo simulation to find the Efficient Frontier.

    Returns:
        results_frame: DataFrame of simulation results (Returns, Volatility, Sharpe)
        max_sharpe_portfolio: Dictionary of weights for Max Sharpe portfolio
        min_vol_portfolio: Dictionary of weights for Min Volatility portfolio
    """
    if stock_data.empty:
        return pd.DataFrame(), {}, {}

    # 1. Calculate Daily Log Returns
    log_returns = np.log(stock_data / stock_data.shift(1)).dropna()
    num_assets = len(stock_data.columns)

    # Prepare arrays for simulation results
    all_weights = np.zeros((num_portfolios, num_assets))
    ret_arr = np.zeros(num_portfolios)
    vol_arr = np.zeros(num_portfolios)
    sharpe_arr = np.zeros(num_portfolios)

    # 2. Run Monte Carlo Simulation
    for i in range(num_portfolios):
        # Generate random weights
        weights = np.array(np.random.random(num_assets))
        weights = weights / np.sum(weights)
        all_weights[i, :] = weights

        # Calculate portfolio metrics
        ret, vol, sharpe = calculate_portfolio_metrics(weights, log_returns)

        ret_arr[i] = ret
        vol_arr[i] = vol
        sharpe_arr[i] = sharpe

    # 3. Compile results into a DataFrame
    simulation_results = {
        'Return': ret_arr,
        'Volatility': vol_arr,
        'Sharpe Ratio': sharpe_arr
    }

    for i, asset in enumerate(stock_data.columns):
        simulation_results[asset + ' Weight'] = all_weights[:, i]

    results_frame = pd.DataFrame(simulation_results)

    # 4. Find the Optimal Portfolios
    max_sharpe_idx = results_frame['Sharpe Ratio'].idxmax()
    min_vol_idx = results_frame['Volatility'].idxmin()

    # Extract weights for max Sharpe portfolio
    max_sharpe_weights_series = results_frame.iloc[max_sharpe_idx][[col for col in results_frame.columns if 'Weight' in col]]
    max_sharpe_portfolio = {
        'Metrics': max_sharpe_weights_series.index.str.replace(' Weight', ''),
        'Weights (%)': (max_sharpe_weights_series.values * 100).round(2)
    }
    max_sharpe_portfolio['Return'] = results_frame.loc[max_sharpe_idx, 'Return']
    max_sharpe_portfolio['Volatility'] = results_frame.loc[max_sharpe_idx, 'Volatility']
    max_sharpe_portfolio['Sharpe Ratio'] = results_frame.loc[max_sharpe_idx, 'Sharpe Ratio']

    # Extract weights for min volatility portfolio
    min_vol_weights_series = results_frame.iloc[min_vol_idx][[col for col in results_frame.columns if 'Weight' in col]]
    min_vol_portfolio = {
        'Metrics': min_vol_weights_series.index.str.replace(' Weight', ''),
        'Weights (%)': (min_vol_weights_series.values * 100).round(2)
    }
    min_vol_portfolio['Return'] = results_frame.loc[min_vol_idx, 'Return']
    min_vol_portfolio['Volatility'] = results_frame.loc[min_vol_idx, 'Volatility']
    min_vol_portfolio['Sharpe Ratio'] = results_frame.loc[min_vol_idx, 'Sharpe Ratio']

    return results_frame, max_sharpe_portfolio, min_vol_portfolio


# --- Streamlit Application Layout ---

def format_number(n, is_currency=False, decimals=2):
    """Formats large numbers for display."""
    if n == 'N/A' or not isinstance(n, (int, float)):
        return 'N/A'

    if is_currency:
        if abs(n) >= 1e12:
            return f"${n/1e12:.{decimals}f}T"
        elif abs(n) >= 1e9:
            return f"${n/1e9:.{decimals}f}B"
        elif abs(n) >= 1e6:
            return f"${n/1e6:.{decimals}f}M"
        else:
            return f"${n:,.{decimals}f}"
    else:
        return f"{n:,.{decimals}f}"


def page_fundamental_analysis():
    """Displays the Fundamental Analysis page."""
    st.title("ðŸ”¬ Fundamental Stock Analysis")
    st.write("Enter a ticker symbol (e.g., AAPL, GOOGL) to view its fundamental data and historical price performance.")

    # Input widget for the ticker
    col1, col2 = st.columns([3, 1])

    # Create a list of top 10 tickers + the full mock universe for the search dropdown
    search_options = sorted(list(set(TICKER_UNIVERSE[:10] + ['AAPL', 'MSFT', 'GOOGL', 'AMZN'] + TICKER_UNIVERSE)))

    selected_ticker = col1.selectbox(
        "Select or type a ticker:",
        options=search_options,
        index=search_options.index('AAPL') if 'AAPL' in search_options else 0,
        key=f'{appId}_ticker_select'
    )

    if selected_ticker and col2.button("Analyze Stock"):
        with st.spinner(f"Fetching data for {selected_ticker}..."):
            # Check for mock ticker
            if selected_ticker.startswith('MOCK'):
                fundamentals = fetch_fundamentals(selected_ticker)

                st.subheader(fundamentals['longName'])
                st.info(fundamentals['longBusinessSummary'])

                # Mock Data Display
                colA, colB, colC = st.columns(3)
                colA.metric("Sector", fundamentals['sector'])
                colB.metric("Market Cap", format_number(fundamentals['marketCap'], is_currency=True, decimals=2))
                colC.metric("P/E Ratio", format_number(fundamentals['trailingPE']))
                st.warning("Note: This is simulated fundamental data. No real price chart available for mock tickers.")

            else:
                # Real Ticker Data Fetching
                fundamentals, prices = fetch_fundamentals(selected_ticker)

                if fundamentals and not prices.empty:
                    st.subheader(f"{fundamentals.get('longName', selected_ticker)} ({selected_ticker})")
                    st.markdown(f"**Sector:** {fundamentals.get('sector', 'N/A')} | **Industry:** {fundamentals.get('industry', 'N/A')}")

                    st.markdown("---")

                    # 1. Key Metrics
                    colA, colB, colC, colD = st.columns(4)

                    colA.metric("Market Cap", format_number(fundamentals.get('marketCap'), is_currency=True, decimals=2))
                    colB.metric("P/E Ratio (TTM)", format_number(fundamentals.get('trailingPE')))
                    colC.metric("Div Yield", f"{fundamentals.get('dividendYield', 0) * 100:.2f}%" if fundamentals.get('dividendYield') != 'N/A' else 'N/A')
                    colD.metric("Shares Outstanding", format_number(fundamentals.get('sharesOutstanding'), decimals=0))

                    # 2. Historical Price Chart
                    st.subheader("Historical Price (Last Year)")
                    fig = px.line(
                        prices,
                        y='Close',
                        title=f'{selected_ticker} Adjusted Closing Price',
                        labels={'Close': 'Price (USD)', 'Date': 'Date'}
                    )
                    fig.update_layout(height=400, showlegend=False)
                    st.plotly_chart(fig, use_container_width=True)

                    # 3. Business Summary
                    with st.expander("Company Business Summary"):
                        st.write(fundamentals.get('longBusinessSummary', 'No business summary available.'))

                elif selected_ticker not in TICKER_UNIVERSE and selected_ticker.isalpha():
                    st.error(f"Ticker '{selected_ticker}' not found or no data available. Please check the symbol.")
                else:
                     st.error("Could not fetch data. Please try a valid ticker like AAPL or GOOGL.")


def page_portfolio_optimizer():
    """Displays the Portfolio Optimization page (Markowitz Efficient Frontier)."""
    st.title("ðŸ“ˆ Portfolio Optimizer (Mean-Variance)")
    st.write("Use the Markowitz model to find the optimal balance between risk and return for your chosen assets.")

    # --- Setup and Input ---

    # Recommended assets for a successful optimization demo
    DEFAULT_ASSETS = ['AAPL', 'GOOGL', 'JPM', 'XOM', 'GLD']

    selected_assets = st.multiselect(
        "Select Assets for Optimization (Min 2):",
        options=[t for t in TICKER_UNIVERSE if not t.startswith('MOCK')],
        default=DEFAULT_ASSETS,
        key=f'{appId}_assets_select'
    )

    col1, col2 = st.columns(2)
    with col1:
        years = st.slider("Historical Data Period (Years):", 1, 10, 5, key=f'{appId}_years_slider')
    with col2:
        num_runs = st.slider("Monte Carlo Simulations:", 1000, 20000, 10000, 1000, key=f'{appId}_runs_slider')

    start_date = (datetime.now() - timedelta(days=int(years * 365.25))).strftime('%Y-%m-%d')
    end_date = datetime.now().strftime('%Y-%m-%d')

    st.info(f"Using historical data from **{start_date}** to **{end_date}** for optimization.")

    st.markdown("---")

    # --- Optimization Logic ---
    if st.button("Run Portfolio Optimization", use_container_width=True):
        if len(selected_assets) < 2:
            st.warning("Please select at least two assets to perform portfolio optimization.")
            return

        # Fetch data
        stock_data = fetch_data(selected_assets, start_date, end_date)

        if stock_data.empty or len(stock_data.columns) < 2:
            st.error("Could not retrieve enough valid historical data for the selected assets. Check tickers/period.")
            return

        # Run optimization
        results_frame, max_sharpe, min_vol = monte_carlo_optimization(stock_data, num_runs)

        # --- Output and Visualization ---

        st.subheader("Efficient Frontier Analysis")
        st.success(f"Simulation Complete: Analyzed {num_runs} portfolios over {years} years of data.")

        # 1. Efficient Frontier Plot
        # Create a scatter plot of all simulated portfolios
        fig = px.scatter(
            results_frame,
            x='Volatility',
            y='Return',
            color='Sharpe Ratio',
            color_continuous_scale=px.colors.sequential.Viridis,
            title='Markowitz Efficient Frontier (Monte Carlo Simulation)'
        )

        # Add Max Sharpe Ratio portfolio point
        fig.add_trace(go.Scatter(
            x=[max_sharpe['Volatility']],
            y=[max_sharpe['Return']],
            mode='markers',
            marker=dict(color='red', size=15, symbol='star', line=dict(width=1, color='black')),
            name=f'Max Sharpe Ratio ({max_sharpe["Sharpe Ratio"]:.2f})'
        ))

        # Add Min Volatility portfolio point
        fig.add_trace(go.Scatter(
            x=[min_vol['Volatility']],
            y=[min_vol['Return']],
            mode='markers',
            marker=dict(color='blue', size=15, symbol='circle', line=dict(width=1, color='black')),
            name=f'Min Volatility ({min_vol["Volatility"]:.2f})'
        ))

        fig.update_layout(
            xaxis_title="Annualized Volatility (Risk)",
            yaxis_title="Annualized Return",
            height=550
        )
        st.plotly_chart(fig, use_container_width=True)
        # Add image to explain the concept
        st.markdown("")


        # 2. Optimal Portfolio Results
        st.subheader("Optimal Portfolio Allocations")

        col_max, col_min = st.columns(2)

        # Max Sharpe Portfolio
        with col_max:
            st.markdown(f"**Max Sharpe Ratio Portfolio**")
            st.metric("Sharpe Ratio", f"{max_sharpe['Sharpe Ratio']:.2f}", help="Highest return per unit of risk.")
            st.metric("Expected Return (Annual)", f"{max_sharpe['Return'] * 100:.2f}%")
            st.metric("Expected Volatility (Annual)", f"{max_sharpe['Volatility'] * 100:.2f}%")

            # Display weights
            weights_df_max = pd.DataFrame({
                'Asset': max_sharpe['Metrics'],
                'Allocation (%)': max_sharpe['Weights (%)']
            }).set_index('Asset')
            st.dataframe(weights_df_max, use_container_width=True)


        # Min Volatility Portfolio
        with col_min:
            st.markdown(f"**Minimum Volatility Portfolio**")
            st.metric("Sharpe Ratio", f"{min_vol['Sharpe Ratio']:.2f}")
            st.metric("Expected Return (Annual)", f"{min_vol['Return'] * 100:.2f}%")
            st.metric("Expected Volatility (Annual)", f"{min_vol['Volatility'] * 100:.2f}%", help="The portfolio with the lowest overall risk.")

            # Display weights
            weights_df_min = pd.DataFrame({
                'Asset': min_vol['Metrics'],
                'Allocation (%)': min_vol['Weights (%)']
            }).set_index('Asset')
            st.dataframe(weights_df_min, use_container_width=True)

        st.markdown(f"**App ID:** `{appId}` (Used for caching and environment integrity)")


# --- Main App Execution ---
def main():
    st.set_page_config(
        page_title="Elaborate Financial Dashboard",
        layout="wide",
        initial_sidebar_state="expanded"
    )

    # Global Style: Apply custom CSS for a cleaner look
    st.markdown("""
        <style>
        .css-1d391kg { padding-top: 35px; } /* Adjust padding for better header look */
        .stButton>button {
            background-color: #4CAF50;
            color: white;
            border-radius: 8px;
            font-weight: bold;
            transition: all 0.2s;
        }
        .stButton>button:hover {
            background-color: #45a049;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
        }
        </style>
    """, unsafe_allow_html=True)

    # Sidebar Navigation
    st.sidebar.title("Navigation")
    menu_selection = st.sidebar.radio(
        "Choose a Tool:",
        ("Portfolio Optimizer", "Fundamental Analysis"),
        key=f'{appId}_menu'
    )

    st.sidebar.markdown("---")
    st.sidebar.markdown(f"**Universe Size:** {len(TICKER_UNIVERSE)} Stocks")
    st.sidebar.caption("Includes large, mid, and mock small-cap names.")
    st.sidebar.markdown("---")
    st.sidebar.caption("Data is fetched from Yahoo Finance via `yfinance`.")

    # Render selected page
    if menu_selection == "Fundamental Analysis":
        page_fundamental_analysis()
    elif menu_selection == "Portfolio Optimizer":
        page_portfolio_optimizer()

if __name__ == '__main__':
    main()